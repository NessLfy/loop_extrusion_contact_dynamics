import numpy as np
import pandas as pd
import nd2
import glob
import os
from ipa.snakemake_utils import predict_stardist_complete
from tqdm import tqdm
import dask.array as da
from zarr_tools import convert

# Define names of the input and output files
threads = int(config["threads"])

FILENAME = [x.split('/')[-1].replace(".nd2", "") for x in glob.glob(f"{config['folder_path']}/*.nd2")]
images = expand("{folder_path}/{filename}.nd2", folder_path=config['folder_path'], filename="{filename}")


detection = "{path}/detections/detections_{filename}_cxy_{crop_sizexy}_cz_{crop_size_z}.csv"

detections = expand("{path}/detections/detections_{filename}_cxy_{crop_sizexy}_cz_{crop_size_z}.csv", filename=FILENAME,
         crop_sizexy=config["crop_size_xy"],
         crop_size_z=config["crop_size_z"],
         path=config["save_path"])


labels = config["save_path"]+"/labels/label_image_{filename}.zarr"

labels_tracked = expand(config['save_path']+"/label_image_tracked/label_image_tracked_{filename}.csv", filename=FILENAME)

label_tracked = config['save_path']+"/label_image_tracked/label_image_tracked_{filename}.csv"

labels_full = directory(config['save_path']+"/labels/label_image_full_{filename}.zarr")

max_threads = os.cpu_count() 

rule all:
    input:
        detections,
        labels_tracked

rule compute_detections:
    input:
        lambda wildcards: f"{config['folder_path']}{wildcards.filename}.nd2",
        labels_full
    output:
        detection
    params:
        crop_size_xy = int(config["crop_size_xy"]),
        crop_size_z = int(config["crop_size_z"])
    threads: threads
    shell:
        """
        python -m ipa.processing_new_kristina --input_image {input[0]} --output_file {output} --labels {input[1]} --crop_size_xy {params.crop_size_xy} --crop_size_z {params.crop_size_z} --threads {threads}
        """

rule compute_labels_full:
    input: images
    output: labels_full
    priority:
        19
    threads:
	    max_threads
    run: 
        im_big = nd2.imread(input[0])

        if len(im_big.shape) != 4:
            im_big = im_big.reshape(im_big.shape[0]//12,12,im_big.shape[1],im_big.shape[2])
        #predict labels
        im = np.max(im_big,axis=1)
        print('Done max proj')
        labels = predict_stardist_complete(im)

        labels = da.from_array(labels, chunks=(1,labels.shape[1],labels.shape[2]))

        convert.to_zarr(
            labels,
            channel_axis=0,
            path=output[0], 
            steps=4
        )


rule track_cells:
    input:
        labels_full
    output:
        label_tracked
    shell:
        """
        python -m ipa.track_cells --labels_file {input} --output_file {output}
        """

EMAIL = config['email']

onsuccess:
   shell("mail -s 'DONE' {EMAIL} < {log}")

onerror:
   shell("mail -s 'ERROR' {EMAIL}")